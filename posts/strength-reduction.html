<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Strength Reduction — emomaxd</title>
  <meta name="description" content="Strength reduction: optimize expensive ops like division into cheaper operations—deep dive and benchmarks." />
  <style>
    :root {
      --bg:#0b0f12;
      --panel:#0f1518;
      --muted:#95a0a6;
      --accent:#7bd389;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'Courier New', monospace;
      --sans: Inter, ui-sans-serif, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue';
    }
    *{box-sizing:border-box}
    body {
      margin:0;
      font-family:var(--sans);
      background:linear-gradient(180deg,var(--bg),#071013 120%);
      color:#e6eef3;
      line-height:1.6;
      padding:32px;
      max-width:780px;
      margin:auto;
    }
    h1,h2,h3{line-height:1.2}
    pre { background:#061014; padding:12px; border-radius:8px; border:1px solid rgba(255,255,255,0.05); font-family:var(--mono); font-size:13px; overflow:auto; }
    code{font-family:var(--mono); background:rgba(255,255,255,0.04); padding:2px 4px; border-radius:4px; font-size:90%;}
    .meta{color:var(--muted); font-size:13px; margin-bottom:16px;}
    a { color:var(--accent); text-decoration:none; }
    a:hover { text-decoration:underline; }
  </style>
</head>
<body>

  <h1>Strength Reduction</h1>
  <div class="meta">Adapted · ~6 min read</div>

  <p>
    Strength reduction is a compiler optimization where expensive operations—like integer division—are replaced with functionally equivalent but much cheaper alternatives. This is not conjecture; it's what modern compilers do in release mode. :contentReference[oaicite:0]{index=0}
  </p>

  <h2>Case 1: is_odd via modulo → bitwise</h2>
  <p>
    Example: checking if a number is odd. Instead of using `% 2`, the compiler emits `x & 1` under the hood. That's strength reduction in action. Clean, simple, and fast. :contentReference[oaicite:1]{index=1}
  </p>

  <h2>Case 2: remainder with constant divisor</h2>
  <p>
    When divisor is a compile-time constant (e.g., `1245` or `892`), compilers can avoid `idiv` entirely—using shifts, multiplies, subtracts, and adds to compute `x % C`. It gets optimized into a sequence of cheap arithmetic ops. :contentReference[oaicite:2]{index=2}
  </p>

  <h2>Case 3: unknown divisor</h2>
  <p>
    If the divisor is dynamic (function parameter), compiler plays safe: it can't strength-reduce, and you get an `idiv` instruction. Straightforward, expected. :contentReference[oaicite:3]{index=3}
  </p>

  <h2>Case 4: benchmark comparison</h2>
  <pre>
// strength-reduced branch (constant divisor)
BENCHMARK(srMod);
v_out[i] = v_in[i] % 1245;

// baseline branch (dynamic divisor)
BENCHMARK(baseMod)->Arg(1245);
v_out[i] = v_in[i] % s.range(0);
  </pre>
  <p>
    Result: strength-reduced version runs in ~4.6 µs, while the dynamic divisor (with real `idiv`) takes ~36 µs. That’s nearly **9× speedup**. :contentReference[oaicite:4]{index=4}
  </p>

  <h2>Your takeaway</h2>
  <p>
    Trust the compiler—but don’t worship. When divisor isn't constant, compiler can't optimize. If you're hand-rolling loops in tight spots (profiling critical paths, HPC code, SIMD kernels), sometimes you need to code strength-reduction yourself—or ensure constants are compile-time fixed. Benchmark relentlessly.
  </p>

  <p><a href="../blog.html">← Back to blog</a></p>

</body>
</html>

