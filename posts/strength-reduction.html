<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>Strength Reduction in Critical Paths</title>
    <style>
        body {
            font-family: monospace;
            margin: 40px auto;
            max-width: 800px;
            line-height: 1.4;
            background: #fafafa;
            color: #222;
        }
        h1 {
            font-size: 18px;
            margin-bottom: 5px;
        }
        h2 {
            font-size: 16px;
            margin: 20px 0 10px 0;
            border-bottom: 1px solid #ccc;
        }
        a {
            color: #000;
        }
        .meta {
            color: #666;
            font-size: 12px;
            margin-bottom: 20px;
        }
        pre {
            background: #f0f0f0;
            padding: 10px;
            overflow-x: auto;
            font-size: 12px;
            border-left: 3px solid #ddd;
        }
        code {
            background: #f0f0f0;
            padding: 2px 4px;
            font-size: 11px;
        }
        .benchmark {
            background: #f8f8f8;
            padding: 15px;
            margin: 15px 0;
            border-left: 3px solid #999;
        }
    </style>
</head>
<body>
    <h1>Strength Reduction in Critical Paths</h1>
    <div class="meta">2025-08-10 • ~4 min read</div>
    
    <p>Strength reduction swaps expensive ops for cheap ones. Division becomes multiplication. Modulo becomes bitwise AND. Your compiler does this automatically—when it can.</p>

    <h2>The Basics</h2>
    <p>Check if number is odd: <code>x % 2</code> becomes <code>x &amp; 1</code>. One instruction instead of dozens. Free performance.</p>
    
    <p>Divide by 8: <code>x / 8</code> becomes <code>x &gt;&gt; 3</code>. Bit shift vs division unit. No contest.</p>

    <h2>Constant vs Variable Divisors</h2>
    <p>Compiler sees <code>x % 1245</code>? Optimizes to multiply-shift sequence. Sees <code>x % divisor</code>? Can't help you—emits <code>idiv</code>.</p>

    <pre>// This gets optimized
for (int i = 0; i < n; i++) {
    if (data[i] % 16 == 0) process(data[i]);
}

// This doesn't 
void func(int divisor) {
    for (int i = 0; i < n; i++) {
        if (data[i] % divisor == 0) process(data[i]);
    }
}</pre>

    <h2>Real Numbers</h2>
    <div class="benchmark">
        <strong>Benchmark: 1M modulo operations</strong><br>
        Constant divisor (1245): <strong>4.6μs</strong><br>
        Variable divisor (1245): <strong>36μs</strong><br>
        Speedup: <strong>7.8x</strong>
    </div>

    <p>Same input, same divisor value. Only difference: compiler knowledge at build time.</p>

    <h2>Manual Strength Reduction</h2>
    <p>Sometimes you know better than the compiler:</p>

    <pre>// Instead of x % (1 &lt;&lt; k)
result = x &amp; ((1 &lt;&lt; k) - 1);

// Instead of x / (1 &lt;&lt; k) 
result = x &gt;&gt; k;

// Replace expensive modulo in loops
// when you know the pattern
int mask = size - 1;  // size must be power of 2
for (int i = 0; i < n; i++) {
    buffer[i &amp; mask] = data[i];
}</pre>

    <h2>Division by Multiplication</h2>
    <p>Classic trick: replace <code>x / d</code> with <code>x * (magic_number) &gt;&gt; shift</code>. Compiler does this for constants. You can do it for known runtime values:</p>

    <pre>// Precompute magic constants for fast division
struct FastDiv {
    uint32_t multiplier;
    uint8_t shift;
};

FastDiv make_fast_div(uint32_t d) {
    // Magic number computation
    int shift = 32 + __builtin_clz(d - 1);
    uint64_t tmp = ((1ULL &lt;&lt; shift) + d - 1) / d;
    return {tmp, shift - 32};
}

uint32_t fast_divide(uint32_t x, FastDiv fd) {
    return ((uint64_t)x * fd.multiplier) &gt;&gt; fd.shift;
}</pre>

    <h2>Branch-Free Conditionals</h2>
    <p>Replace branches with arithmetic when possible:</p>

    <pre>// Instead of
if (x &lt; 0) x = -x;

// Use
int mask = x &gt;&gt; 31;  // -1 if negative, 0 if positive
x = (x ^ mask) - mask;</pre>

    <h2>SIMD Considerations</h2>
    <p>Vector units hate division. Design algorithms around this:</p>

    <pre>// Bad: division in inner loop
for (int i = 0; i < n; i += 8) {
    __m256i v = _mm256_load_si256(&amp;data[i]);
    v = _mm256_div_epi32(v, divisor);  // Slow
}

// Good: reciprocal multiplication
float reciprocal = 1.0f / divisor;
for (int i = 0; i < n; i += 8) {
    __m256 v = _mm256_load_ps(&amp;data[i]);
    v = _mm256_mul_ps(v, _mm256_set1_ps(reciprocal));
}</pre>

    <h2>Profile Everything</h2>
    <p>Strength reduction isn't always worth it. Measure:</p>

    <pre># Check what compiler actually emits
gcc -O3 -S your_code.c
objdump -d your_binary

# Profile hotspots
perf record -g ./your_program
perf report</pre>

    <p>Sometimes the "slow" operation isn't the bottleneck. Sometimes your clever optimization makes code unreadable for 2% gain. Pick your battles.</p>

    <h2>Bottom Line</h2>
    <p>Compiler handles obvious cases. You handle the subtle ones. Know your tools, profile your assumptions, and remember—premature optimization kills more projects than slow division ever will.</p>

    <p><a href="../index.html">← Back</a></p>
</body>
</html>
